<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    

    <script>
        // //----------------------------------------
        // // 배열 : 여러 자료Type을 저장하기 위한 자료구조
        // // 배열은 순서번호(Index) 를 가지고 있고 번호를 통해서 요소값에 접근가능
        // //----------------------------------------
        // let arr=['str1',"str2",`str3`,null,true,false,undefined,{name:"홍길동",age:15}];
        // console.log(arr);
        // console.log(typeof arr[0]);
        // console.log(typeof arr[1]);
        // console.log(typeof arr[2]);
        // console.log(typeof arr[3]);
        // console.log(typeof arr[4]);
        // console.log(typeof arr[5]);
        // console.log(typeof arr[6]);
        // console.log(typeof arr[7]);
        // //----------------------------------------
        // //자바스크립트의 배열은 동적확장이 가능하다
        // //----------------------------------------
        // arr[8] = 100;
        // console.log(arr);
        // arr[10] = "HELLO WORLD";
        // console.log(arr);
        // console.log(typeof arr[9] , typeof arr[10])

        // //----------------------------------------
        // // 배열함수 : push(마지막 index+1 에 값 추가) , pop(마지막 index 값 제거)
        // //----------------------------------------
        // arr.push('aaa');
        // arr.push('bbb');
        // arr.push('ccc');
        // console.log(arr);
        // arr.pop();
        // arr.pop();
        // console.log(arr);
        //----------------------------------------
        // 배열함수 : forEach
        // 배열 내의 모든 요소를 순차적으로 접근하는 반복구문
        // Callback함수(로직을 전달, ()=>{})
        // arr.forEach((요소명)=>{처리할 코드})
        //----------------------------------------
        // console.log("-------------------");
        // arr.forEach((item)=>{ console.log('item',item); });

        // //----------------------------------------
        // // 정렬 : sort((비교인자1,비교인자2)=>{return 비교인자1 - 비교인자2})
        // // 오름차순 : arr.sort((a,b)=>{return a-b})
        // // 내림차순 : arr.sort((a,b)=>{return b-a})
        // // 기존 배열에서 정렬 진행
        // //----------------------------------------
        // let arr2=[10,55,11,24,5,44,1,22]
        // //오름차순 정렬
        // // arr2.sort((a,b)=>{return a-b;}); //
        // //내림차순 정렬
        // // arr2.sort((a,b)=>{return b-a;}); //
        // //약식
        // arr2.sort((a,b)=>b-a); //
        // console.log(arr2);

        // //----------------------------------------
        // // 필터 : 배열내에서 특정 요소만 필터링
        // // arr.filter((요소명)=>{return 조건식})
        // // 필터링된 요소만 묶은 배열이 따로 생성
        // //----------------------------------------
        // let arr3=[11,'str1',22,"str2",33,`str3`,10.5,null,true,false,undefined,101,{name:"홍길동",age:15}];

        // let result = arr3.filter((item)=>{return typeof item=="number"});
        // console.log(result);
        
        // let result2 = arr3.filter((item)=>{return typeof item=="string"});
        // console.log(result2);

        // //----------------------------------------
        // //누산 : 누적합,누적곱.... 누적작업
        // //arr.reduce((누적변수,요소명)=>{처리로직},누산변수 초기값)
        // //----------------------------------------
        // const sum = arr3.filter((item)=>{return typeof item=="number"})         //숫자값만 필터
        //                 .reduce((sum,item)=>{return sum+item;},0)               //누적합 구하기

        // console.log(sum);

        //----------------------------------
        // 배열object 처리 [{},{},{},{}...]
        //----------------------------------
        // let arr_5 = [
        //     {pid:"1",pname:"모니터",price:100,amount:50},
        //     {pid:"2",pname:"노트북",price:200,amount:15},
        //     {pid:"3",pname:"냉장고",price:250,amount:30},
        //     {pid:"4",pname:"데스크탑",price:70,amount:19},
        //     {pid:"5",pname:"가습기",price:10,amount:200},
        // ];
        // console.log(arr_5);
        // arr_5.forEach((item)=>{console.log(item);})
        // arr_5.forEach(item=>console.log(item))
        // arr_5.forEach((item,index)=>{console.log(index,item);})
        // arr_5.forEach((item,index)=>{console.log(item["price"]);})

        // 각 item의 가격이 100이상인 object만 필터링
        // // const filter_01 = arr_5.filter(item=>item["price"]>=100)
        // const filter_01 = arr_5.filter(item=>item.price>=100)
        // console.log(filter_01);

        // // 각 아이템 수량이 30개 이하인 object만 필터링(>=,<=)
        // const filter_02= arr_5.filter(item=>item.amount<=30)
        // console.log(filter_02);
        
        // // 각 아이템 가격이 100만원 이상인 item의 가격 총합(누적)을 구하세요
        // const sum = arr_5.filter((item)=>{return item.price>=100;})
        //                  .reduce((sum,item)=>{return sum + (item.price*item.amount);},0);
        // console.log('100만원 이상인 item의 price 누적합',sum);                        

        //----------------------------------
        // map : 기존 배열의 새로운 형태의 배열로 재구성 
        // arr.map((요소명)=>{return 재구성할 요소의 형태})
        // 새로운 배열이 만들어짐
        //----------------------------------
        // let arr_6 = [
        //     {pid:"1",pname:"모니터",price:100,amount:50},
        //     {pid:"2",pname:"노트북",price:200,amount:15},
        //     {pid:"3",pname:"냉장고",price:250,amount:30},
        //     {pid:"4",pname:"데스크탑",price:70,amount:19},
        //     {pid:"5",pname:"가습기",price:10,amount:200},
        // ];
        // let maped_01 = arr_6.map((item)=>{
        //     item={...item,"total_price":item.price*item.amount};
        //     console.log("!",item);
        //     return item;
        // })
        // console.log(maped_01);

        // 수량이 30이상인 요소만 필터링해서/ price가 낮은값우선 오름차순 / price*amount 항목 추가
        // const maped_02 = arr_6.filter((item)=>{return item.amount>=30})
        //                       .sort((a,b)=>{return a.price-b.price;})                              
        //                       .map((item)=>{
        //                         item={...item,"total_price":item.price*item.amount};
        //                         return item;
        //                     })

        // console.log(maped_02);

        
        let employees = [
            { id: 1, name: "김철수", age: 35, department: "개발", salary: 6000, years: 10 },
            { id: 2, name: "이영희", age: 28, department: "디자인", salary: 5000, years: 5 },
            { id: 3, name: "박지성", age: 40, department: "마케팅", salary: 7000, years: 15 },
            { id: 4, name: "손흥민", age: 30, department: "개발", salary: 6500, years: 7 },
            { id: 5, name: "정우성", age: 45, department: "경영", salary: 9000, years: 20 },
            { id: 6, name: "한지민", age: 29, department: "디자인", salary: 5200, years: 6 },
            { id: 7, name: "강호동", age: 50, department: "경영", salary: 8500, years: 25 },
            { id: 8, name: "유재석", age: 42, department: "마케팅", salary: 7500, years: 18 },
            { id: 9, name: "송중기", age: 32, department: "개발", salary: 6200, years: 8 },
            { id: 10, name: "수지", age: 26,  department: "디자인", salary: 4800, years: 3 }
        ];

        // 연봉이(salary) 6000이상이면서 근속연수(years)가 7년이상인(item.salary>=6000 && item.years>=7) 직원만 필터링해서 배열로 저장 확인
        // const result1 =  employees.filter((item)=>{return item.salary>=6000 && item.years>=7})   
        // console.log(result1);




        // 모든 직원의 연봉(salary) 기준으로 내림차순 정렬한 배열 새로 만들기
        // employees.sort((a,b)=>{return b.salary-a.salary;})
        // console.log(employees)


        // 모든 직원의 연봉(salary) 에 근속연수*100 만큼의 보너스를 추가하여 total_salary필드를 추가한 배열을 반환
        // const result3 = employees.map((item)=>{
        //     item = {...item,"total_salary": item.salary+(item.years*100) }
        //     return item;
        // })

        // console.log(result3);

        // department(부서) 별로 직원들의 연봉총합을 구하세요
        // sum = {"개발": "", "마케팅":""}
        // console.log(employees)
        // const result4 = employees.reduce((sum,item)=>{
        //     // console.log(item);
        //     sum[item.department]=sum[item.department]==undefined?item.salary:sum[item.department]+item.salary;
        //     console.log(sum);
        //     return sum;
        // },{});
        // console.log(result4);
       

        // 연봉(salary)가 가장높은 직원을 찾아 객체하나만 반환(mdn문서에서 find를 찾아보세요 - !)
        const max_item = employees.sort((a,b)=>{return b.salary-a.salary;})[0];
        console.log(max_item);

        //최대값 구하기
        const max_item2 = employees.find((item)=>{return item.salary==max_item.salary;});
        console.log(max_item2);



    </script>

</body>
</html>